<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Isometric Swarm Prototype</title>
  <style>
    :root {
      color-scheme: dark;
      --bg: #0c0f16;
      --ground: #152233;
      --hud: rgba(14, 18, 28, 0.9);
      --hud-stroke: #1f2a3d;
      --accent: #60a5fa;
      --muted: #7b8ca7;
    }

    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: "Inter", system-ui, -apple-system, sans-serif;
      background: radial-gradient(circle at 20% 20%, #11192b, #0c0f16 40%),
        radial-gradient(circle at 80% 0%, #0f233b, #0c0f16 50%);
      color: #e5e7eb;
      overflow: hidden;
    }

    canvas {
      display: block;
      width: 100vw;
      height: 100vh;
      background: transparent;
    }

    .overlay {
      position: fixed;
      inset: 0;
      pointer-events: none;
      display: flex;
      flex-direction: column;
      justify-content: flex-end;
      padding: 20px 24px;
    }

    .hud-row {
      display: grid;
      grid-template-columns: 280px 1fr 280px;
      gap: 16px;
      align-items: flex-end;
      pointer-events: none;
    }

    .panel {
      pointer-events: auto;
      background: var(--hud);
      border: 1px solid var(--hud-stroke);
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.35);
      border-radius: 10px;
      padding: 8px 10px;
      display: flex;
      gap: 8px;
      justify-content: center;
      align-items: center;
    }

    .slot {
      width: 44px;
      height: 44px;
      border: 1px solid var(--hud-stroke);
      border-radius: 8px;
      background: linear-gradient(180deg, rgba(255,255,255,0.04), rgba(0,0,0,0.2));
      display: grid;
      place-items: center;
      color: var(--muted);
      font-size: 14px;
      letter-spacing: 0.4px;
      text-shadow: 0 1px 0 rgba(0,0,0,0.6);
    }

    .hotbar {
      display: flex;
      gap: 8px;
      justify-content: center;
      align-items: center;
    }

    .inventory {
      justify-content: flex-end;
      flex-wrap: wrap;
    }

    .info {
      position: fixed;
      top: 14px;
      left: 16px;
      padding: 10px 12px;
      border-radius: 10px;
      border: 1px solid var(--hud-stroke);
      background: rgba(12, 15, 22, 0.85);
      color: #cbd5e1;
      max-width: 280px;
      font-size: 14px;
      line-height: 1.4;
      pointer-events: none;
      box-shadow: 0 8px 20px rgba(0, 0, 0, 0.35);
    }
  </style>
</head>
<body>
  <canvas id="game"></canvas>
  <div class="info">
    <strong>Isometric Swarm Prototype</strong><br />
    Click anywhere to move. Dark particles will drift toward you.<br />
    Spells (left) and inventory (right) are placeholders for future actions.
  </div>
  <div class="overlay">
    <div class="hud-row">
      <div class="panel hotbar" id="spells"></div>
      <div></div>
      <div class="panel hotbar inventory" id="inventory"></div>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');

    const world = {
      width: 3200,
      height: 3200,
    };

    const player = {
      x: world.width / 2,
      y: world.height / 2,
      targetX: world.width / 2,
      targetY: world.height / 2,
      speed: 200,
    };

    const camera = { x: 0, y: 0 };
    const trees = [];
    const rocks = [];
    const enemies = [];

    function resize() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resize);
    resize();

    function randomRange(min, max) {
      return Math.random() * (max - min) + min;
    }

    function spawnDecor() {
      const treeCount = 90;
      const rockCount = 70;
      for (let i = 0; i < treeCount; i++) {
        trees.push({ x: randomRange(100, world.width - 100), y: randomRange(100, world.height - 100), size: randomRange(18, 26) });
      }
      for (let i = 0; i < rockCount; i++) {
        rocks.push({ x: randomRange(100, world.width - 100), y: randomRange(100, world.height - 100), size: randomRange(10, 18) });
      }
    }

    function spawnEnemies() {
      const swarm = 45;
      for (let i = 0; i < swarm; i++) {
        enemies.push({
          x: randomRange(0, world.width),
          y: randomRange(0, world.height),
          vx: 0,
          vy: 0,
          wobble: Math.random() * Math.PI * 2,
        });
      }
    }

    spawnDecor();
    spawnEnemies();

    canvas.addEventListener('click', (e) => {
      const rect = canvas.getBoundingClientRect();
      const mouseX = e.clientX - rect.left;
      const mouseY = e.clientY - rect.top;
      player.targetX = camera.x + mouseX;
      player.targetY = camera.y + mouseY;
    });

    function updateCamera() {
      camera.x = player.x - canvas.width / 2;
      camera.y = player.y - canvas.height / 2;
      camera.x = Math.max(0, Math.min(world.width - canvas.width, camera.x));
      camera.y = Math.max(0, Math.min(world.height - canvas.height, camera.y));
    }

    function movePlayer(dt) {
      const dx = player.targetX - player.x;
      const dy = player.targetY - player.y;
      const dist = Math.hypot(dx, dy);
      if (dist > 1) {
        const step = player.speed * dt;
        const t = Math.min(step / dist, 1);
        player.x += dx * t;
        player.y += dy * t;
      }
    }

    function updateEnemies(dt) {
      const attractRadius = 650;
      enemies.forEach((enemy) => {
        enemy.wobble += dt * 1.5;
        const dx = player.x - enemy.x + Math.cos(enemy.wobble) * 40;
        const dy = player.y - enemy.y + Math.sin(enemy.wobble * 1.3) * 40;
        const dist = Math.hypot(dx, dy);
        const speed = dist < attractRadius ? 60 : 15;
        const t = dist > 0 ? speed * dt / dist : 0;
        enemy.x += dx * t;
        enemy.y += dy * t;
        enemy.vx = dx * t;
        enemy.vy = dy * t;
      });
    }

    function drawGround() {
      const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
      gradient.addColorStop(0, '#0e1726');
      gradient.addColorStop(1, '#0a0d14');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // isometric guide grid
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.04)';
      ctx.lineWidth = 1;
      const spacing = 140;
      ctx.beginPath();
      for (let x = -world.height; x < world.width + world.height; x += spacing) {
        const sx1 = x - camera.x;
        const sy1 = -camera.y;
        const sx2 = x + world.height - camera.x;
        const sy2 = world.height - camera.y;
        ctx.moveTo(sx1, sy1);
        ctx.lineTo(sx2, sy2);
      }
      for (let x = world.height; x > -world.width; x -= spacing) {
        const sx1 = x - camera.x;
        const sy1 = -camera.y;
        const sx2 = x - world.height - camera.x;
        const sy2 = world.height - camera.y;
        ctx.moveTo(sx1, sy1);
        ctx.lineTo(sx2, sy2);
      }
      ctx.stroke();
    }

    function drawDiamond(x, y, size, fill, stroke) {
      ctx.beginPath();
      ctx.moveTo(x, y - size);
      ctx.lineTo(x + size, y);
      ctx.lineTo(x, y + size);
      ctx.lineTo(x - size, y);
      ctx.closePath();
      ctx.fillStyle = fill;
      ctx.fill();
      if (stroke) {
        ctx.strokeStyle = stroke;
        ctx.lineWidth = 2;
        ctx.stroke();
      }
    }

    function drawDecor() {
      trees.forEach((tree) => {
        const sx = tree.x - camera.x;
        const sy = tree.y - camera.y;
        drawDiamond(sx, sy + 6, tree.size, '#0c1b11', '#132a1b');
        ctx.fillStyle = '#1f3d2a';
        ctx.beginPath();
        ctx.moveTo(sx, sy - tree.size * 0.6);
        ctx.lineTo(sx + tree.size * 0.8, sy + tree.size * 0.6);
        ctx.lineTo(sx - tree.size * 0.8, sy + tree.size * 0.6);
        ctx.closePath();
        ctx.fill();
        ctx.fillStyle = '#2d5f3b';
        ctx.beginPath();
        ctx.moveTo(sx, sy - tree.size * 1.2);
        ctx.lineTo(sx + tree.size * 0.7, sy + tree.size * 0.3);
        ctx.lineTo(sx - tree.size * 0.7, sy + tree.size * 0.3);
        ctx.closePath();
        ctx.fill();
      });

      rocks.forEach((rock) => {
        const sx = rock.x - camera.x;
        const sy = rock.y - camera.y;
        drawDiamond(sx, sy, rock.size * 0.8, '#1c2230', '#2c3546');
      });
    }

    function drawEnemies() {
      enemies.forEach((enemy) => {
        const sx = enemy.x - camera.x;
        const sy = enemy.y - camera.y;
        const pulse = 3 + Math.sin(enemy.wobble * 3) * 1.5;
        drawDiamond(sx, sy, 10 + pulse, 'rgba(14,14,18,0.85)', 'rgba(0,0,0,0.5)');
        ctx.fillStyle = 'rgba(48,54,69,0.7)';
        ctx.beginPath();
        ctx.arc(sx, sy, 3 + pulse * 0.3, 0, Math.PI * 2);
        ctx.fill();
      });
    }

    function drawPlayer() {
      const sx = player.x - camera.x;
      const sy = player.y - camera.y;
      drawDiamond(sx, sy, 14, '#6ee7b7', '#0f766e');
      ctx.fillStyle = '#0ea5e9';
      ctx.beginPath();
      ctx.arc(sx, sy - 4, 4, 0, Math.PI * 2);
      ctx.fill();
    }

    function render() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawGround();
      drawDecor();
      drawEnemies();
      drawPlayer();
    }

    let last = performance.now();
    function loop(now) {
      const dt = (now - last) / 1000;
      last = now;
      movePlayer(dt);
      updateCamera();
      updateEnemies(dt);
      render();
      requestAnimationFrame(loop);
    }
    requestAnimationFrame(loop);

    function buildHud() {
      const spells = ['Q', 'W', 'E', 'R', 'T'];
      const inventory = ['1', '2', '3', '4', '5', '6'];
      const spellEl = document.getElementById('spells');
      spells.forEach((label) => {
        const slot = document.createElement('div');
        slot.className = 'slot';
        slot.textContent = label;
        spellEl.appendChild(slot);
      });

      const inventoryEl = document.getElementById('inventory');
      inventory.forEach((label) => {
        const slot = document.createElement('div');
        slot.className = 'slot';
        slot.textContent = label;
        inventoryEl.appendChild(slot);
      });
    }

    buildHud();
  </script>
</body>
</html>
